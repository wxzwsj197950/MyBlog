---
layout:     post
title:      "Http的缓存学习笔记"
subtitle:   "ETag与Cache-Control"
date:       2016-02-02 13:03:00
author:     "Wuxx"
header-img: "img/post-bg-04.jpg"
---

HTTP1.1版本中**Cache-Control+ETag**替代了1.0的**Expires+last-****modified**用来控制浏览器对缓存的操作。

## 1.ETag ##
当浏览器第一次访问一个页面后，服务器返回一个ETag表示页面的特征，比如页面文件的md5，当浏览器又要发起对这个地址的请求时，浏览器先去寻找浏览器之前的缓存，查看它有没有过期，如果过期，就带着先前的页面的ETag(这里是页面的md5）去访问服务器。服务器把客户端发来的ETag和当前页面的Etag对比，如果文件被修改过（md5变了)，那么就返回新的页面，否则指示浏览器用缓存，因为ETag一样的页面内容也是完全一样的，没必要再次获取。

## 2.Cache-Control ##
Cache-Control可以设置这么几个参数：

**1.****no-cache**：表示每次都请求服务器。虽然叫no-cache但不代表一定不会用缓存。。。浏览器会请求与服务器匹配ETag，ETag一样的话还是会用缓存的内容，只不过多了一次与服务器确认ETag的请求而已。这与设置缓存存在时间为0差不多。。。

**2.no-store**:这个是真的不会用缓存了。。。如字面意思，不存储缓存，都不存储了你还去哪里读呢。。。

**3.public**：我们不是直接和最终服务器对话的，中间可能有代理服务器，设置public就是允许任何能保存缓存的服务器保存缓存。

**4.private**:设置private我们就只允许发送请求的浏览器保存缓存了，而代理服务器不会保存缓存。

**5.max-age**:顾名思义，缓存存在的最长时间，设为0就和no-cache差不多了。。

## 废弃已用缓存 ##
如果我们页面更新了，比如换了个css样式，那怎么让客户端获取新的资源呢？

1.对于新客户，之前没访问过，没有缓存，那么他肯定会获取到最新资源。

2.对于访问过的客户，但是缓存已过期，则由于新页面和旧页面ETag不同，按之前介绍的ETag的策略，浏览器也能获得最新页面。

3.对于已访问但是缓存还没过期的客户，他会直接使用缓存而不与服务器确认文件是否更新。所以这种客户使用的还是老的页面。

这种客户只能等他缓存过期或者手动清除缓存了吗?其实我们只要改变资源的地址就好了。

比如<link rel="stylesheet" href="www.xxx.yyy?v=123456">
这个v代表页面的版本，也可以用md5值（因为你一旦更新了页面md5肯定变了，网站也就肯定变了）。这样一来，地址变了浏览器就把它当做从没访问过的资源来访问啦。